"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const pluginutils_1 = require("@rollup/pluginutils");
const fs_1 = require("fs");
const core_1 = require("@embroider/core");
const assert_never_1 = __importDefault(require("assert-never"));
const path_1 = require("path");
function rollupHbsPlugin() {
    return {
        name: 'rollup-hbs-plugin',
        async resolveId(source, importer, options) {
            let resolution = await this.resolve(source, importer, {
                skipSelf: true,
                ...options,
            });
            if (!resolution) {
                return maybeSynthesizeComponentJS(this, source, importer, options);
            }
            else {
                return maybeRewriteHBS(resolution);
            }
        },
        load(id) {
            const meta = getMeta(this, id);
            if (!meta) {
                return;
            }
            switch (meta.type) {
                case 'template':
                    this.addWatchFile(meta.originalId);
                    let input = (0, fs_1.readFileSync)(meta.originalId, 'utf8');
                    let code = (0, core_1.hbsToJS)(input);
                    return {
                        code,
                    };
                case 'template-only-component-js':
                    return {
                        code: templateOnlyComponent,
                    };
                default:
                    (0, assert_never_1.default)(meta);
            }
        },
    };
}
exports.default = rollupHbsPlugin;
const templateOnlyComponent = `import templateOnly from '@ember/component/template-only';\n` +
    `export default templateOnly();\n`;
function getMeta(context, id) {
    var _a, _b;
    const meta = (_b = (_a = context.getModuleInfo(id)) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b['rollup-hbs-plugin'];
    if (meta) {
        return meta;
    }
    else {
        return null;
    }
}
function correspondingTemplate(filename) {
    let { ext } = (0, path_1.parse)(filename);
    return filename.slice(0, filename.length - ext.length) + '.hbs';
}
async function maybeSynthesizeComponentJS(context, source, importer, options) {
    let templateResolution = await context.resolve(correspondingTemplate(source), importer, {
        skipSelf: true,
        ...options,
    });
    if (!templateResolution) {
        return null;
    }
    // we're trying to resolve a JS module but only the corresponding HBS
    // file exists. Synthesize the template-only component JS.
    return {
        id: templateResolution.id.replace(/\.hbs$/, '.js'),
        meta: {
            'rollup-hbs-plugin': {
                type: 'template-only-component-js',
            },
        },
    };
}
const hbsFilter = (0, pluginutils_1.createFilter)('**/*.hbs');
function maybeRewriteHBS(resolution) {
    if (!hbsFilter(resolution.id)) {
        return null;
    }
    // This creates an `*.hbs.js` that we will populate in `load()` hook.
    return {
        ...resolution,
        id: resolution.id + '.js',
        meta: {
            'rollup-hbs-plugin': {
                type: 'template',
                originalId: resolution.id,
            },
        },
    };
}
//# sourceMappingURL=rollup-hbs-plugin.js.map